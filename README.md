# 小米商城 - Go 电商平台开发全流程

这是一个结构化、循序渐进的 **Go 电商平台开发全流程**。我们将整个项目划分为 **6 个核心阶段**。

这种分阶段开发模式（Milestone-based）的好处是：每完成一个阶段，你都有一个可运行、可测试的产物，而不是等到最后才发现一堆 Bug 耦合在一起。

---

## 📅 阶段一：顶层设计与基础设施搭建 (Blueprint & Infra)

**目标**：确立"骨架"，跑通由 Docker 编排的基础环境，代码能连接到所有中间件。

### 1. 需求与建模 (Design)

- **ER 图设计**：这是最关键的一步。确定 `User`、`Product` (SPU/SKU)、`Order`、`Cart` 等核心表结构。
- **API 规范**：定义 RESTful 接口路径（如 `POST /api/v1/seckill/orders`）和 JSON 响应格式。

### 2. 环境编排 (Docker)

- 编写 `docker-compose.yaml`，包含：MySQL 8, Redis 7, RabbitMQ (带管理后台), Elasticsearch 7.x, Kibana。
- 确保容器间网络互通。

### 3. 脚手架初始化 (Scaffold)

- **目录结构**：建立标准 Go 目录 (`cmd`, `internal`, `pkg`, `conf`)。
- **基础组件封装**：
  - **GORM**: 配置连接池、日志、自动迁移。
  - **Redis**: 封装客户端。
  - **Zap Logger**: 配置日志切割。
  - **Viper**: 读取 `config.yaml`。
  - **Snowflake**: 集成雪花算法，用于生成全局唯一的订单 ID。

> ✅ **阶段产物**：一个能启动的 Go Web 服务，访问 `ping` 接口返回 `pong`，且 Docker 环境全绿。

---

## 📅 阶段二：核心业务功能开发 (Core Business - CRUD)

**目标**：实现电商最基本的"买卖"流程（不含高并发优化），保证业务逻辑正确。

### 1. 用户模块 (User)

- 注册（密码 Bcrypt 加密）、登录（签发 JWT Token）。
- 实现 **JWT 中间件**，解析 Token 并将 `user_id` 注入 Gin 上下文。

### 2. 商品模块 (Product)

- **OSS 集成**：封装阿里云 OSS，实现图片上传。
- **管理后台**：创建分类、创建商品（SPU）、设置规格价格（SKU）。
- **用户前台**：商品列表查询（先查 DB）、商品详情。

### 3. 购物车 (Cart)

- 使用 Redis `Hash` 结构存储购物车数据 (`user_id` -> `sku_id` -> `count`)。
- 实现添加、删除、清空购物车。

> ✅ **阶段产物**：用户可以注册登录，后台可以上传商品，前台可以看到商品并加入购物车。

---

## 📅 阶段三：订单交易系统 (Transaction & Order)

**目标**：攻克电商最复杂的"钱"和"库存"问题，确保数据准确。

### 1. 订单下单 (Place Order)

- **库存扣减**：使用 GORM 乐观锁 (`version` 字段) 或 SQL 条件 (`update ... set stock = stock - 1 where stock > 0`)。
- **事务一致性**：在同一个事务中完成：扣减库存 -> 创建订单 -> 创建订单详情 -> 清空购物车。

### 2. 支付模拟 (Payment)

- 集成支付宝沙箱 SDK，或编写一个 Mock 接口模拟回调。
- 处理回调逻辑：校验签名 -> 更新订单状态 (待支付 -> 待发货)。

### 3. 状态机 (State Machine)

- 严格控制订单状态流转（只能 0->1, 1->2，不能 0->3）。

> ✅ **阶段产物**：用户能走完正常的下单流程，数据库里的库存和订单状态准确无误。

---

## 📅 阶段四：搜索与解耦 (Search & Decoupling via MQ)

**目标**：引入 RabbitMQ 和 ES，提升性能，解决复杂业务流转。

### 1. RabbitMQ 基础封装

- 封装 Producer 和 Consumer，实现断线重连。
- 定义交换机 (Exchange) 和队列 (Queue) 绑定关系。

### 2. ES 商品搜索同步

- **场景**：后台修改商品 -> MySQL 更新 -> 发送 MQ 消息。
- **消费者**：监听消息 -> 调用 ES Go 客户端 (`olivere/elastic`) -> 更新索引。
- 实现前台的**全文搜索**接口。

### 3. 订单超时自动关闭 (Delay Queue)

- **场景**：下单后 30 分钟未支付，自动取消。
- **实现**：安装 RabbitMQ 延迟插件，下单成功发送延迟消息。消费者收到消息后检查支付状态，若未支付则关单并归还库存。

> ✅ **阶段产物**：搜索速度飞快；下单后不支付，30分钟后订单自动变"已关闭"。

---

## 📅 阶段五：高并发秒杀优化 (Seckill & Optimization)

**目标**：这是项目的**核心亮点**，抗住流量洪峰。

### 1. 读性能优化

- **缓存预热**：秒杀开始前，将 SKU 库存加载到 Redis。
- **防缓存击穿**：在查询商品详情接口引入 `Singleflight`。
- **防缓存穿透**：引入布隆过滤器。

### 2. 写性能优化 (秒杀核心)

- **Lua 脚本**：编写 Redis Lua 脚本，实现原子性的"资格校验 + 扣减库存"。
- **削峰填谷**：Lua 扣减成功 -> 发送"创建订单"消息到 MQ -> 立即返回前端。
- **异步落库**：后台 Consumer 慢慢消费 MQ，创建真实 MySQL 订单。

### 3. 限流与安全

- **Gin 限流中间件**：基于 Redis ZSet 实现滑动窗口限流，拦截刷子请求。

> ✅ **阶段产物**：JMeter 压测下，QPS 大幅提升，数据库 CPU 稳定，且没有超卖现象。

---

## 📅 阶段六：工程化与运维 (DevOps & Polish)

**目标**：让项目具备上线标准，代码整洁。

### 1. 优雅停机 (Graceful Shutdown)

- 监听系统信号，关闭服务时确保 MQ 里的消息消费完再退出。

### 2. 链路追踪 (Jaeger) - 可选

- 如果时间充裕，集成 Jaeger 查看 API 到 DB/Redis/MQ 的调用耗时。

### 3. 部署脚本

- 完善 `Makefile` (一键 build, run, clean)。
- 配置 Nginx 反向代理与静态资源缓存。

---

## 🚀 当前进度

当前处于 **阶段一 (Design)**。

### 下一步行动

为了不让你在写代码时反复修改数据库，需要先完成 "数据建模"。

**待完成任务**：
- [ ] 完整的数据库 ER 设计
- [ ] GORM 结构体定义
- [ ] API 接口规范文档

---

## 📁 项目结构

```
xiaomi-mall/
├── cmd/                    # 应用入口
│   └── main.go
├── internal/               # 私有应用代码
│   ├── api/               # API 处理层
│   ├── service/           # 业务逻辑层
│   ├── repository/        # 数据访问层
│   ├── model/             # 数据模型
│   └── pkg/               # 内部工具包
├── conf/                   # 配置文件
│   └── config.yaml
├── deploy/                 # 部署相关
│   └── docker-compose.yaml
└── README.md
```

---

## 🛠️ 技术栈

- **框架**: Gin
- **ORM**: GORM
- **数据库**: MySQL 8
- **缓存**: Redis 7
- **消息队列**: RabbitMQ
- **搜索引擎**: Elasticsearch 7.x
- **日志**: Zap
- **配置**: Viper
- **ID 生成**: Snowflake

---

## 📝 开发规范

- 遵循 Go 标准项目布局
- 使用 Git Flow 工作流
- 代码提交前需通过 golangci-lint 检查
- 每个阶段完成后需要编写测试用例

---

## 📖 文档

详细的 API 文档和数据库设计文档将在阶段一完成后补充。
